import { BarChartType, ChartDataType, ChartType, TreeMapChartType } from "@allurereport/charts-api";
import { severityLevels, statusesList } from "@allurereport/core-api";
import { interpolateRgb } from "d3-interpolate";
import { scaleLinear } from "d3-scale";
import { generateLayerColors, resolveCSSVarColor, severityColors, statusChangeColors, statusColors } from "./colors.js";
export const createTrendChartDataGeneric = (getChart, getGroups, getColor) => {
    const chart = getChart();
    if (!chart) {
        return undefined;
    }
    const items = getGroups().reduce((acc, group) => {
        const pointsByGroupBy = chart.series[group]?.map((pointId) => {
            const point = chart.points[pointId];
            return {
                x: point.x,
                y: point.y,
            };
        }) ?? [];
        if (pointsByGroupBy.length) {
            acc.push({
                id: group.charAt(0).toUpperCase() + group.slice(1),
                data: pointsByGroupBy,
                color: getColor(group),
            });
        }
        return acc;
    }, []);
    return {
        type: chart.type,
        dataType: chart.dataType,
        mode: chart.mode,
        title: chart.title,
        items,
        slices: Object.values(chart.slices),
        min: chart.min,
        max: chart.max,
    };
};
export const createBarChartDataGeneric = (getChart, getColors) => {
    const chart = getChart();
    if (!chart) {
        return undefined;
    }
    return {
        ...chart,
        colors: getColors(),
    };
};
export const createTreeMapChartDataGeneric = (getChart, colors, formatLegend, legendDomain, tooltipRows) => {
    const chart = getChart();
    if (!chart) {
        return undefined;
    }
    return {
        ...chart,
        colors,
        formatLegend,
        legendDomain,
        tooltipRows,
    };
};
export const createHeatMapChartDataGeneric = (getChart, colors) => {
    const chart = getChart();
    if (!chart) {
        return undefined;
    }
    return {
        ...chart,
        colors,
    };
};
export const createStatusTrendChartData = (chartId, res) => createTrendChartDataGeneric(() => res[chartId], () => statusesList, (status) => statusColors[status]);
export const createSeverityTrendChartData = (chartId, res) => createTrendChartDataGeneric(() => res[chartId], () => severityLevels, (severity) => severityColors[severity]);
export const createStatusBySeverityBarChartData = (chartId, res) => createBarChartDataGeneric(() => res[chartId], () => statusColors);
export const createStatusTrendBarChartData = (chartId, res) => createBarChartDataGeneric(() => res[chartId], () => statusColors);
export const createStatusChangeTrendBarChartData = (chartId, res) => createBarChartDataGeneric(() => res[chartId], () => statusChangeColors);
export const createDurationsByLayerBarChartData = (chartId, res) => {
    const chart = res[chartId];
    if (!chart) {
        return undefined;
    }
    const layerNames = chart.keys;
    return {
        ...chart,
        colors: generateLayerColors(layerNames),
    };
};
export const createFbsuAgePyramidBarChartData = (chartId, res) => {
    const chart = res[chartId];
    if (!chart) {
        return undefined;
    }
    return {
        ...chart,
        colors: statusColors,
    };
};
export const createStabilityRateDistributionBarChartData = (chartId, res) => {
    const chart = res[chartId];
    if (!chart) {
        return undefined;
    }
    return {
        ...chart,
        colors: {},
    };
};
export const createSuccessRateDistributionTreeMapChartData = (chartId, res) => {
    const chartColorDomain = [0, 1];
    return createTreeMapChartDataGeneric(() => res[chartId], (value, domain = chartColorDomain) => {
        const scaledRgb = scaleLinear()
            .domain(domain)
            .range([resolveCSSVarColor(statusColors.failed), resolveCSSVarColor(statusColors.passed)])
            .interpolate(interpolateRgb)
            .clamp(true);
        return scaledRgb(value);
    }, (value) => {
        if (value === 1) {
            return "passed";
        }
        return "failed";
    }, chartColorDomain, (node) => {
        return [`passed: ${node.data.passedTests}`, `failed: ${node.data.failedTests}`, `other: ${node.data.otherTests}`];
    });
};
export const createCoverageDiffTreeMapChartData = (chartId, res) => {
    const chartColorDomain = [0, 0.5, 1];
    return createTreeMapChartDataGeneric(() => res[chartId], (value, domain = chartColorDomain) => {
        const scaledRgb = scaleLinear()
            .domain(domain)
            .range([resolveCSSVarColor(statusColors.failed), "#fff", resolveCSSVarColor(statusColors.passed)])
            .interpolate(interpolateRgb)
            .clamp(true);
        return scaledRgb(value);
    }, (value) => {
        if (value === 1) {
            return "new";
        }
        return "removed";
    }, chartColorDomain, (node) => {
        const newTotal = node.data.newCount + node.data.enabledCount;
        const deletedTotal = node.data.deletedCount + node.data.disabledCount;
        const unchangedTotal = node.value - newTotal - deletedTotal;
        return [`new: ${newTotal}`, `deleted: ${deletedTotal}`, `unchanged: ${unchangedTotal}`];
    });
};
export const createProblemsDistributionHeatMapChartData = (chartId, res) => {
    const chartColorDomain = [0, 1];
    return createHeatMapChartDataGeneric(() => res[chartId], (value, domain = chartColorDomain) => {
        const scaledRgb = scaleLinear()
            .domain(domain)
            .range([resolveCSSVarColor(statusColors.passed), resolveCSSVarColor(statusColors.failed)])
            .interpolate(interpolateRgb)
            .clamp(true);
        return scaledRgb(value);
    });
};
export const createaTrendChartData = (chartId, chartData, res) => {
    if (chartData.dataType === ChartDataType.Status) {
        return createStatusTrendChartData(chartId, res);
    }
    else if (chartData.dataType === ChartDataType.Severity) {
        return createSeverityTrendChartData(chartId, res);
    }
};
export const createBarChartData = (chartId, chartData, res) => {
    switch (chartData.dataType) {
        case BarChartType.StatusBySeverity:
            return createStatusBySeverityBarChartData(chartId, res);
        case BarChartType.StatusTrend:
            return createStatusTrendBarChartData(chartId, res);
        case BarChartType.StatusChangeTrend:
            return createStatusChangeTrendBarChartData(chartId, res);
        case BarChartType.DurationsByLayer:
            return createDurationsByLayerBarChartData(chartId, res);
        case BarChartType.FbsuAgePyramid:
            return createFbsuAgePyramidBarChartData(chartId, res);
        case BarChartType.StabilityRateDistribution:
            return createStabilityRateDistributionBarChartData(chartId, res);
    }
};
export const createTreeMapChartData = (chartId, chartData, res) => {
    if (chartData.dataType === TreeMapChartType.SuccessRateDistribution) {
        return createSuccessRateDistributionTreeMapChartData(chartId, res);
    }
    else if (chartData.dataType === TreeMapChartType.CoverageDiff) {
        return createCoverageDiffTreeMapChartData(chartId, res);
    }
};
export const createHeatMapChartData = (chartId, res) => {
    return createProblemsDistributionHeatMapChartData(chartId, res);
};
export const createCharts = (res) => {
    return Object.entries(res).reduce((acc, [chartId, chart]) => {
        if (chart.type === ChartType.Trend) {
            const chartData = createaTrendChartData(chartId, chart, res);
            if (chartData) {
                acc[chartId] = chartData;
            }
        }
        else if (chart.type === ChartType.Bar) {
            const chartData = createBarChartData(chartId, chart, res);
            if (chartData) {
                acc[chartId] = chartData;
            }
        }
        else if (chart.type === ChartType.TreeMap) {
            const chartData = createTreeMapChartData(chartId, chart, res);
            if (chartData) {
                acc[chartId] = chartData;
            }
        }
        else if (chart.type === ChartType.HeatMap) {
            const chartData = createHeatMapChartData(chartId, res);
            if (chartData) {
                acc[chartId] = chartData;
            }
        }
        else if ([ChartType.Pie, ChartType.ComingSoon].includes(chart.type)) {
            acc[chartId] = chart;
        }
        return acc;
    }, {});
};
export const createChartsWithEnvs = (res) => {
    if (!("general" in res) && !("byEnv" in res)) {
        return { general: createCharts(res), byEnv: {} };
    }
    const result = {
        general: createCharts(res.general),
        byEnv: {},
    };
    for (const [env, chartData] of Object.entries(res.byEnv)) {
        result.byEnv[env] = createCharts(chartData);
    }
    return result;
};
