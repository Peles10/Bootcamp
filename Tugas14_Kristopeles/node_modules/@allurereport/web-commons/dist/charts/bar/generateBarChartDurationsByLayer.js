import { BarChartType, BarGroupMode, ChartMode, ChartType, } from "@allurereport/charts-api";
export const generateBarChartDurationsByLayer = (options, storeData) => {
    const testsDurationsByLayer = new Map();
    const { testResults } = storeData;
    for (const testResult of testResults) {
        const layer = testResult.labels.find((label) => label.name === "layer")?.value;
        const duration = testResult.duration;
        if (!layer || !duration || isNaN(duration)) {
            continue;
        }
        if (!testsDurationsByLayer.has(layer)) {
            testsDurationsByLayer.set(layer, []);
        }
        testsDurationsByLayer.get(layer)?.push(duration);
    }
    if (testsDurationsByLayer.size === 0) {
        return {
            data: [],
            type: ChartType.Bar,
            dataType: BarChartType.DurationsByLayer,
            mode: ChartMode.Raw,
            title: options.title,
            keys: [],
            groupMode: BarGroupMode.Stacked,
            indexBy: "groupId",
        };
    }
    const allDurations = Array.from(testsDurationsByLayer.values()).flat();
    const maxBuckets = Math.min(6, allDurations.length);
    const sortedDurations = [...allDurations].sort((a, b) => a - b);
    const buckets = [];
    if (maxBuckets === 1) {
        buckets.push({
            min: Math.min(...allDurations),
            max: Infinity,
            label: `${Math.round(Math.min(...allDurations))}+ms`,
        });
    }
    else {
        for (let i = 0; i < maxBuckets; i++) {
            const quantile = i / maxBuckets;
            const nextQuantile = (i + 1) / maxBuckets;
            const minIndex = Math.floor(quantile * (sortedDurations.length - 1));
            const maxIndex = Math.floor(nextQuantile * (sortedDurations.length - 1));
            const bucketMin = sortedDurations[minIndex];
            const bucketMax = i === maxBuckets - 1 ? sortedDurations[sortedDurations.length - 1] : sortedDurations[maxIndex];
            const label = i === maxBuckets - 1 ? `${Math.round(bucketMin)}+ms` : `${Math.round(bucketMin)}-${Math.round(bucketMax)}ms`;
            buckets.push({
                min: bucketMin,
                max: bucketMax,
                label,
            });
        }
    }
    const layerNames = Array.from(testsDurationsByLayer.keys());
    const bucketCounts = new Map();
    for (const layer of layerNames) {
        bucketCounts.set(layer, new Map());
        for (let i = 0; i < buckets.length; i++) {
            bucketCounts.get(layer).set(i.toString(), 0);
        }
    }
    for (const [layer, durations] of testsDurationsByLayer) {
        for (const duration of durations) {
            for (let i = 0; i < buckets.length; i++) {
                const bucket = buckets[i];
                if (duration >= bucket.min && duration < bucket.max) {
                    const currentCount = bucketCounts.get(layer).get(i.toString()) || 0;
                    bucketCounts.get(layer).set(i.toString(), currentCount + 1);
                    break;
                }
            }
        }
    }
    const chartData = buckets
        .map((bucket, bucketIndex) => {
        const dataPoint = {
            groupId: bucket.label,
        };
        let totalTests = 0;
        for (const layer of layerNames) {
            const count = bucketCounts.get(layer)?.get(bucketIndex.toString()) || 0;
            dataPoint[layer] = count;
            totalTests += count;
        }
        return { dataPoint, totalTests };
    })
        .filter(({ totalTests }) => totalTests > 0)
        .map(({ dataPoint }) => dataPoint);
    if (chartData.length === 0) {
        return {
            data: [],
            type: ChartType.Bar,
            dataType: BarChartType.DurationsByLayer,
            mode: ChartMode.Raw,
            title: options.title,
            keys: [],
            groupMode: BarGroupMode.Stacked,
            indexBy: "groupId",
        };
    }
    return {
        data: chartData,
        type: ChartType.Bar,
        dataType: BarChartType.DurationsByLayer,
        mode: ChartMode.Raw,
        title: options.title,
        keys: layerNames,
        groupMode: BarGroupMode.Stacked,
        indexBy: "groupId",
        xAxisConfig: {
            legend: "Duration",
        },
        yAxisConfig: {
            legend: "Number of Tests",
            format: " >-~s",
            tickValues: 5,
        },
    };
};
